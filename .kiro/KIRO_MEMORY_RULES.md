# ğŸ“‹ KIRO MEMORY RULES - SignLand Project

## ğŸ¯ HACKATHON DOCUMENTATION PATTERNS (Extracted from Examples)

### DEVLOG.md Structure Rules
1. **Header Format**: Project name, duration, total time tracked
2. **Overview Section**: Brief project description and tech approach
3. **Weekly Breakdown**: Organize by weeks, then days within weeks
4. **Day Entry Format**:
   - `### Day X (Date) - Focus Area [Xh]`
   - Time ranges with specific activities
   - **Decision**: Technical choices made
   - **Challenge**: Problems encountered
   - **Solution**: How problems were solved
   - **Kiro Usage**: Which prompts/features were used
5. **Technical Decisions Section**: Rationale for architecture choices
6. **Time Breakdown Table**: Category, hours, percentage
7. **Kiro CLI Usage Statistics**: Total prompts, most used, custom prompts created
8. **Final Reflections**: What went well, what could improve, key learnings, innovation highlights

### README.md Structure Rules
1. **Header**: Project name with clear tagline
2. **Prerequisites**: Exact versions and tools needed
3. **Quick Start**: Numbered steps with actual commands
4. **Architecture Overview**: High-level system components
5. **Directory Structure**: ASCII tree showing key folders
6. **Key Components**: Brief description of main files/modules
7. **Deep Dive**: Detailed explanation of core processes
8. **Troubleshooting**: Common issues with solutions
9. **Getting Help**: Where to find more information

### Kiro CLI Integration Patterns
1. **Always mention specific prompts used**: `@prime`, `@plan-feature`, `@execute`, `@code-review`
2. **Track prompt usage statistics**: Count how many times each prompt was used
3. **Document custom prompts created**: Show workflow innovation
4. **Reference steering documents**: Show how they guided development
5. **Mention time saved**: Estimate efficiency gains from Kiro automation

---

## ğŸ—ï¸ PROJECT STRUCTURE RULES

### Monorepo Layout for Hackathon + Amplify
```
repo-root/                    # Hackathon documentation (judges see this first)
â”œâ”€â”€ .kiro/                    # Kiro CLI configuration (REQUIRED for judging)
â”‚   â”œâ”€â”€ steering/             # Project context (product, tech, structure)
â”‚   â””â”€â”€ prompts/              # Custom workflow commands
â”œâ”€â”€ README.md                 # Main project documentation (REQUIRED)
â”œâ”€â”€ DEVLOG.md                 # Development timeline (REQUIRED for 20% of score)
â”œâ”€â”€ amplify.yml               # AWS Amplify build config (points to /web)
â”œâ”€â”€ plans/                    # Feature plans generated by @plan-feature
â”œâ”€â”€ execution-reports/        # Reports generated by @execution-report
â””â”€â”€ web/                      # Next.js application (actual code)
    â”œâ”€â”€ app/                  # Next.js App Router
    â”œâ”€â”€ components/           # React components
    â”œâ”€â”€ lib/                  # Utilities and business logic
    â””â”€â”€ package.json          # Dependencies
```

### File Naming Conventions
- **React Components**: PascalCase (`GestureRecognizer.tsx`)
- **Utilities**: camelCase (`gestureStabilizer.ts`)
- **API Routes**: kebab-case (`refine-text/route.ts`)
- **Types**: PascalCase with `.types.ts` suffix (`Gesture.types.ts`)
- **Documentation**: kebab-case for markdown (`gesture-mapping.md`)
- **Root docs**: UPPERCASE (`README.md`, `DEVLOG.md`)

---

## ğŸ¯ SIGNLAND-SPECIFIC RULES

### Architecture Principles
1. **Privacy-First**: No video upload in Fast Mode, only text tokens in Smart Mode
2. **Offline-First**: Fast Mode must work without internet
3. **Client-Side Processing**: MediaPipe runs in browser (WASM)
4. **Dual-Mode Design**: Fast Mode (instant) vs Smart Mode (refined)
5. **Performance Target**: < 500ms latency in Fast Mode

### Technology Stack
- **Frontend**: Next.js 14+ (App Router), React 18+, TypeScript
- **AI/CV**: MediaPipe Tasks Vision (WASM) for gesture recognition
- **Speech**: Web Speech API (SpeechSynthesis) for TTS
- **Auth**: Clerk for user authentication
- **Optional AI**: Google Gemini API for text refinement
- **Deployment**: AWS Amplify with monorepo support

### Key Components to Build
1. **GestureRecognizer**: MediaPipe integration for hand tracking
2. **Stabilizer**: Debounce/consensus algorithm to prevent false positives
3. **SpeechOutput**: TTS management with voice selection
4. **CaptionDisplay**: Real-time text display
5. **Smart Mode API**: `/api/refine` endpoint for Gemini integration

### Code Organization Patterns
```
web/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ (public)/page.tsx              # Landing page
â”‚   â”œâ”€â”€ (auth)/translate/page.tsx      # Main gesture interface
â”‚   â”œâ”€â”€ (auth)/settings/page.tsx       # User preferences
â”‚   â””â”€â”€ api/refine/route.ts            # Gemini API endpoint
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ mediapipe/                     # MediaPipe setup and processing
â”‚   â”œâ”€â”€ speech/                        # TTS utilities
â”‚   â”œâ”€â”€ translate/                     # Stabilizer, mapping, tokenizer
â”‚   â””â”€â”€ gemini/                        # Gemini API client
â”œâ”€â”€ components/
â”‚   â””â”€â”€ ui/                            # Reusable UI components
â””â”€â”€ hooks/
    â”œâ”€â”€ useGestureRecognizer.ts
    â”œâ”€â”€ useSpeechSynthesis.ts
    â””â”€â”€ useStabilizer.ts
```

---

## ğŸ† HACKATHON JUDGING CRITERIA (100 Points)

### Application Quality (40 points)
- **Functionality & Completeness** (15): Does it work as intended?
- **Real-World Value** (15): Does it solve a genuine problem?
- **Code Quality** (10): Well-structured and maintainable?

### Kiro CLI Usage (20 points)
- **Effective Use of Features** (10): Leverage Kiro CLI capabilities
- **Custom Commands Quality** (7): Quality of custom prompts
- **Workflow Innovation** (3): Creative use of Kiro features

### Documentation (20 points)
- **Completeness** (9): All required docs present
- **Clarity** (7): Easy to understand and follow
- **Process Transparency** (4): Clear development process

### Innovation (15 points)
- **Uniqueness** (8): Original approach or solution
- **Creative Problem-Solving** (7): Novel technical solutions

### Presentation (5 points)
- **Demo Video** (3): Clear demonstration (2-5 minutes)
- **README** (2): Professional project overview

---

## âš¡ KIRO CLI WORKFLOW RULES

### Core Development Loop
1. **Start every session**: `@prime` to load project context
2. **Plan features**: `@plan-feature` â†’ creates plan in `/plans` folder
3. **Execute plans**: `@execute` â†’ systematically implement
4. **Review quality**: `@code-review` â†’ maintain code quality
5. **Generate reports**: `@execution-report` â†’ document implementation
6. **Before submission**: `@code-review-hackathon` â†’ evaluate against criteria

### Custom Prompt Creation Guidelines
- Create prompts for repetitive tasks
- Name prompts clearly: `@analyze-gesture`, `@test-mediapipe`
- Document prompts in DEVLOG
- Show workflow innovation (worth 3 points!)

### Steering Document Maintenance
- Update as project evolves
- Keep technical decisions documented
- Reference in DEVLOG entries
- Show how they guided development

---

## ğŸš€ AWS AMPLIFY DEPLOYMENT RULES

### amplify.yml Configuration
```yaml
version: 1
applications:
  - appRoot: web              # Points to Next.js app subfolder
    frontend:
      phases:
        preBuild:
          commands:
            - npm ci
        build:
          commands:
            - npm run build
      artifacts:
        baseDirectory: .next   # Next.js build output
        files:
          - '**/*'
      cache:
        paths:
          - node_modules/**/*
          - .next/cache/**/*
```

### Environment Variables (Set in Amplify Console)
- `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`: Clerk public key
- `CLERK_SECRET_KEY`: Clerk secret key (server-side)
- `GEMINI_API_KEY`: Google Gemini API key (optional)
- `NEXT_PUBLIC_APP_URL`: Deployed app URL

---

## ğŸ“ DEVLOG UPDATE RULES

### Update After Every Development Session
1. **Date and time**: When you worked
2. **Duration**: How long you worked
3. **What you built**: Specific features/components
4. **Technical decisions**: Why you chose specific approaches
5. **Challenges**: Problems encountered
6. **Solutions**: How you solved them
7. **Kiro usage**: Which prompts/features you used
8. **Time tracking**: Update category breakdown table

### Categories to Track
- Planning & Setup
- Backend Development
- Frontend Development
- AI Integration (MediaPipe, Gemini)
- Testing & Debugging
- Documentation

---

## ğŸ¨ CODE QUALITY RULES

### TypeScript Standards
- **Strict mode enabled**: No implicit any
- **Explicit return types**: For all functions
- **Interface over type**: For object shapes
- **Descriptive naming**: `recognizeGesture()` not `rg()`

### React Patterns
- **Server Components by default**: Use 'use client' only when needed
- **Custom hooks**: For reusable logic
- **Component composition**: Over prop drilling
- **Error boundaries**: For graceful failure

### Testing Requirements
- **Unit tests**: Stabilizer/tokenizer logic (deterministic)
- **Component tests**: GestureRecognizer, SpeechOutput, CaptionDisplay
- **Integration tests**: Camera flow, audio flow, gesture-to-speech flow
- **Target**: 80%+ coverage for core logic

---

## ğŸ”’ SECURITY & PRIVACY RULES

### Privacy-First Design
- **No video upload**: Webcam stream never leaves device in Fast Mode
- **Token-only transmission**: Smart Mode sends only text, not video
- **Local processing**: All gesture recognition client-side
- **User control**: Explicit permissions for camera and audio

### Authentication
- **Clerk integration**: Secure user authentication
- **Protected routes**: `/translate` and `/settings` require auth
- **API route protection**: Clerk middleware on `/api/refine`

### Input Validation
- **Sanitize tokens**: Before sending to Gemini
- **Rate limiting**: On `/api/refine` endpoint
- **Error handling**: Prevent information leakage

---

## ğŸ“Š PERFORMANCE REQUIREMENTS

### Latency Targets
- **Fast Mode**: < 500ms from stable gesture to speech
- **Smart Mode**: < 2s from token submission to refined speech
- **Frame processing**: 30 FPS minimum
- **UI responsiveness**: < 100ms for interactions

### Optimization Strategies
- **Prefer local TTS voices**: `localService: true` to avoid network
- **Debounce gesture commits**: Reduce unnecessary processing
- **Lazy load MediaPipe**: Models only when needed
- **Minimize re-renders**: React.memo and useMemo

---

## ğŸ¯ SUBMISSION CHECKLIST

### Required Files (Root Level)
- [ ] README.md - Complete with setup instructions
- [ ] DEVLOG.md - Comprehensive development timeline
- [ ] amplify.yml - AWS Amplify configuration
- [ ] .kiro/steering/ - All three steering documents
- [ ] .kiro/prompts/ - Custom prompts (if created)
- [ ] plans/ - Feature implementation plans
- [ ] execution-reports/ - Implementation reports

### Required Code (web/ folder)
- [ ] Next.js app with App Router
- [ ] MediaPipe gesture recognition
- [ ] Gesture stabilizer logic
- [ ] Web Speech API integration
- [ ] Clerk authentication
- [ ] Gemini API integration (Smart Mode)

### Before Submission
- [ ] Run `@code-review-hackathon` for evaluation
- [ ] Test deployment on AWS Amplify
- [ ] Record 2-5 minute demo video
- [ ] Verify all documentation is complete
- [ ] Check all links and references work

---

## ğŸ’¡ REMEMBER

1. **Update DEVLOG daily** - Don't wait until the end
2. **Use Kiro CLI extensively** - It's 20% of your score
3. **Document everything** - Process documentation is 20% of score
4. **Build something useful** - Real-world value is heavily weighted
5. **Test on real devices** - Camera and TTS work differently on mobile
6. **Privacy is key** - No video upload is a core feature
7. **Performance matters** - Sub-500ms latency is critical
8. **Show your work** - Plans, reports, and DEVLOG demonstrate process

---

This document serves as the "memory" for the SignLand project, capturing all essential patterns, rules, and guidelines extracted from the hackathon examples and requirements.
